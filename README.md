# Техническое задание
# 1 Назначение разработки
Создание двух консольных приложениий для распределенных вычеслений 

## 1.1 Функциональное назначение 
Функциональное назначение разделено в рамках этапности реализации:
Этап 1:
- Прием данных  для обработки в txt формате задачником  и отправка его обработчику
- Задание функции в задачник и передача данной функции для расчетов в обработчик
Этап 2:
- Разделение полученных данных в обрабочике, который получил данные от задачника
- Отправка данных и заданной функции в другие подулюченные обработчики
- Обработка полученных данных через заданную функцию
- Отправка обработанных данных от всех обработчиков в обработчик связанный с задачником   
- Склеивание данных в соотвествии с первоночальными данными
- Отправка обработанных данных в задачник

# 2 Основания для разработки 
Требования заказчика

# 3 Требования к программе или программному изделию

## 3.1 Требования к функциональным характеристикам

### Клиент
1. Приём данных
   - Принимаем ключи, переданные программе
        - Если ключ ввода -f, то запрашиваем файл 
        - Если ключ ввода отсутствует, то зарпашиваем массив чисел, в качестве делимитера - пробел
        - Если ключ ввода неверный (-N, где N!=f), то запускаем как будто бы ключа передано не было

    - Запрашиваем данные по выше описанным правилам
    - Парсим функцию и массив(файл)
    - Верифицируем формат данных

2. Устновка соединения
    - Отправляем запрос на подключение к кластеру (BroadCast)
    - Получаем первый ответ, остальные игнорируем (Получаем самого быстрого в плане интернет-общения)
    - Инициализируем TCP-сессию

3. Передача данных
    - Сериализация ранее полученных данных (скорее всего Binary, но вопрос ещё открытый)
    - По установленному TCP-соединению передаём данные от пользователя

4. Приём данных
    - Получаем сериализованный обработанный массив данных
    - Десериализуем полученные данные
    - Если ключ файлового вывода (-of) был установлен, то записываем все данные в ранее указанный файл, иначе просто выводим в stdout

### Обработчик
1. Инициализация кластера
    - При включении выполняем у себя команду CPU-info, кэшируя количество операций в секунду, которое может выполнять наш процессор (Запоминаем его производительность)
    - Получаем Token-Timer (до 100 mc) и по его истечению отправляем Discovery запрос в кластер, направленный на поиск всех доступных узлов
    - В Discovery-ответе мы дополнительно прикрепляем свою производительность
    - Получаем ответы от всех обработчиков, формируем список доступных обработчиков
    
2. Ожидаем соединения
    - Производим observing сокета

3. Приём данных
    - Обрабатываем подключение клиента
    - Получаем сериализованные данные
    - Десерриализуем данные

4. Обработка данных
    - Делим массив данных пропорционально производительности каждого из доступных обработчиков
    - Используя TCP соединение внутри кластера отправляем каждому обработчику его часть массива и функцию-обработчик, запоминая его смещение
    - Обрабатываем свою часть
    - Собираем обработанные части со всех обработчиков с учётом ранее запомненных смещений

5. Возврат обработанных данных
    - Сериализуем обработанный массив данных
    - По TCP - соединению отправляем данные клиенту
 
## 3.1 Список разрабатываемых модулей ПО

1. Парсер входных/выходных данных
    - Отделяет функцию от основного массива данных
    - Внутри массива делает функциональный strip по пробелу, параллельно преобразуя каждую подстроку в float
 
2. Сетевое ядро 
    - Обработчики инициализируют свой открытый tcp сокет
    - Обработчики начинают Observing своего сокета
    - Обработчики устанавливают соединение друг с другом путём Discovery-запросов/ответов (см. Инициализация кластера)

3. Сериализатор данных (Binary)
    - Вычисляем длину строки, содержащую математическую функцию
    - Записываем длинну самым первым байтом (Получаем ограничение на длину математической функции 255 символов)
    - Сериализует математическую функцию (каждая строка - 1 байт)
    - Кластерами по 4 байта записываем float числа из массива данных

4. Вычислительное ядро
    - Токенизируем математическое выражение на токены (arg - аргумент = 'x'; op - оператор = см. Поддерживаеммые операторы; func - функция = см. Поддерживаемые функции)
    - Вместо токенов аргумента подставляем текущее значение "x"
    - Проходимся по токенам функций и вычисляем их значение
    - Проходимся по токенам операции в соответствии с приоритетом математических операций, постепенно вычисляя значение выражения
    - Возвращаем вычисленное значение как float


# 4 Сценарии использования 
1. Открыть консольные приложения обработчиков
2. Открыть консольное приложение задачника
3. В консольном приложении задачника задать функцию для обработки, входные данные и название выходного файла на латинице 
4. В папке со входными данными появляюется txt файл с обработанными данными

# 5 Сценарии тестирования
Предусловие: Открытые приложения обработчиков и задачника
Основной поток: 
1. Пользователь вводит функцию для обработки и путь до входных данных
2. Задачник сериализует входные данные и передает их в обработчик
3. Обработчик парсит входные данные и функцию
4. Обработчик передает спарсенные данные в другие подключенные обработчики
5. Каждый обработчик обрабатывает полученные данные через переданную функцию
6. Каждый обработчик передает обработанные данные в обработчик связанный с задачником
7. Обработчик связанный с задачником склеивает полученные обработанные данные в том же пордяке в котором получил от задачника
8. Обработчик связанный с задачником передает объединенные данные в задачник 
9. Задачник сохраняет полученные обработанные данные в txt формате в папке со входными данными с заданным названием в п.1

